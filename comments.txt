*************************** 
https://www.youtube.com/watch?v=jdfNnNccDt0
Till 40:23
Tab navigation, tabBar stylize, tabBar icons are done
****************************

1. Why Tabs is not styling by StyleSheet?

2. Icons - Ionicons from expo-router

3. Icon size={size} color={color}. Why?

*************************** 
https://www.youtube.com/watch?v=jdfNnNccDt0
From 40:23 till 53:28
Dark and Light mode
****************************

!!!!! TypeScript interfeisu lietoÅ¡ana ReactNative
!!!!! Context API lietoÅ¡ana ReactNative
!!!!! Provider lietoÅ¡ana ReactNative
!!!!! useContext lietoÅ¡ana ReactNative
!!!!! useState lietoÅ¡ana ReactNative
!!!!! useEffect lietoÅ¡ana ReactNative
!!!!! asyncStorage lietoÅ¡ana ReactNative


1. Local Storage - lai atcereetos kÄdu tÄ“mu izvÄ“lÄ“jÄs lietotÄjs.

2. To nodroÅ¡ina speciÄls hook(s)

3. Local storage vietÄ izmantojam async-storage

npm i @react-native-async-storage/async-storage

4. jÄizveido themeProvider (fails ar 132 rindÄm koda tÄ«rÄ React ar Typescript un nekÄ no ReactNative, izÅ†emot async-storage pakotni). 
- importÄ“jam useState, useEffect un asyncStorage.
- Providerim ir useState - kas seko kÄds reims izvÄ“lÄ“ts
- useEffect - lai iegaumÄ“tu lietotÄja izvÄ“li pÄ“dÄ“jÄ sistÄ“mas palaiÅ¡anas reizÄ“.
- tad tiek izsaukta metode toggleDarkMode - kas Ä¼auj pÄrslÄ“gt tÄ“mas un atjauno asyncStorage noglabÄtos datus (Dark modÄ“ izmantojam agrÄk nodefinÄ“tÄs tumÅ¡Äs krÄsas, Ligh ModÄ“ - gaiÅ¡Äs).
- Lai to nodroÅ¡inÄtu izveidojam hooku useTheme, kurÅ¡ izsauc context.
- const useTheme = () => {
    const context = useContext(ThemeContext);
    if (context === undefined) {
        throw new Error("useTheme must be used within a ThemeProvider");
    }

    return context;
};

5. Tagad pamata _layoutÄ (ne tab layoutÄ) viss kods jÄietin (wrap), lai varÄ“tu izmantot Light un Dark modes. 

6. Ietinam visu ThemeProviderÄ« (ko importÄ“jam nevis no react-native, bet no ../hooks/useTheme)

import { Stack } from "expo-router";
import { ThemeProvider } from "../hooks/useTheme";
import React from "react";

export default function RootLayout() {
  return (
    <ThemeProvider>
      <Stack screenOptions={{
        headerShown: false,
      }}>
        <Stack.Screen name="(tabs)" />
      </Stack>
    </ThemeProvider>
  );
}

7. Tagad pielabojam (tabs) screenus,lai izmantotu themes nodefinÄ“tÄs krÄsas (color={color} etc.).
....
import { useTheme } from '../../hooks/useTheme';

  <Tabs screenOptions={{
            tabBarActiveTintColor: colors.primary,
            tabBarInactiveTintColor: colors.textMuted,
            tabBarStyle: {
                backgroundColor: colors.surface,
                borderTopWidth: 1,
                borderTopColor: colors.border,
.......

app lieto LightMode, jo hookaa useTheme useState sÄkumstÄvoklis ir false, bet     const colors = isDarkMode ? darkColors : lightColors;
tÄtad sÄkumÄ sanÄk light Mode.

8. Pievienojam tÄ“mu pÄrslÄ“gÅ¡anas toggle pogu (pÄrbaudam - tabBar maina tÄ“mu. PÄrstartÄ“jot app, tÄ“ma ir tÄ,kas bija pirms app aizvÄ“rÅ¡anas jo stÄvooklis saglabÄjas async storage (local - iekÄrtÄ kurÄ instalÄ“ta app)) - importÄ“jam hooku, pievienojam no hooka toggleDarkMode metodi un uzrakstam uzrakstu "Toggle Mode"

import React from 'react'
import { StyleSheet, Text, View, TouchableOpacity } from 'react-native'
import useTheme from '../../hooks/useTheme'

export default function Index() {
    const { toggleDarkMode } = useTheme()

    return (
        <View style={styles.container}>
            <Text>Index</Text>
            <TouchableOpacity onPress={toggleDarkMode}>
                <Text>Toggle Mode</Text>
            </TouchableOpacity>
        </View>
    )
}

Tagad tÄ“mu pÄrslÄ“gÅ¡ana darbojas, to vÄ“lÄk realizÄ“sim ar atseviÅ¡ku pÄrslÄ“gÅ¡anas komponentu setting screenÄ.

*************************** 
https://www.youtube.com/watch?v=jdfNnNccDt0
From 53:28 till 1:10:00
Add DataBase and configure schema and functions
****************************

1. izmantojam backendam Convex (lÄ«dz 20 projektiem - bez maksas)  (var Firebase vai Supabase)- the backend AI  (DB, autentifikÄcija, fona uzdevumi un citas funkcijas)

2. Projektu ConvexÄ var izveidot convex admin paneli vai no IDE terminÄÄ¼a:
- vienÄ terminÄlÄ« palaists npx expo
- otrÄ terminÄlÄ« -   npm i convex
tad -   npx convex dev

3. convex mapÄ“ izveido schema.ts failu. tad tajÄ izveido db tabulu sheemu.

import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
    todos: defineTable({
        text: v.string(),
        isCompleted: v.boolean(),
    }),
});


//PÄ“c schema.ts saglabÄÅ¡anas tev ir jÄizpilda:
bash
npx convex deploy
ğŸ‘‰ Å Ä« komanda:
augÅ¡upielÄdÄ“ shÄ“mu uz Convex backendu,
atjauno metadatus admin panelÄ«.
Ja tu esi tikai palaidis npx convex dev, tad shÄ“ma var bÅ«t lokÄli aktÄ«va, bet neparÄdÄs admin panelÄ«.

//Vai schema.ts satur export default defineSchema(...)?
Convex identificÄ“ shÄ“mu caur export default. Ja tu esi eksportÄ“jis to citÄdÄk (piemÄ“ram, export const schema = ...), tad tÄ netiks uzskatÄ«ta par aktÄ«vo shÄ“mu.
Pareizi bÅ«tu:
ts
import { defineSchema, defineTable } from "convex/schema";

export default defineSchema({
  klienti: defineTable({
    vÄrds: "string",
    e_pasts: "string",
    izveidots: "number",
  }),
});


// â—ï¸ SvarÄ«gi: jÄbÅ«t export default, nevis export const.

// pÄ“c DB pieslÄ“gÅ¡anas visu laiku JÄ€IZMANTO DIVI TERMINÄ€Ä»I VIENLAIKUS !!!!

VIENÄ€ - npx expo start
OTRÄ€ - npx convex dev // tas nodroÅ¡inÄs veikto izmaiÅ†u atjaunoÅ¡anu concex kontÄ.

*********************

convex mapÄ“ izveido failu todo.ts

// lai iegÅ«tu datus - sÅ«tam pieprasÄ«jumu (query )GET)
) uz db, lai rediÄ£Ä“tu vai dzÄ“stu ierakstu - jÄizmanto mutÄcija (createTodo, updateTodo, deleteTodo).

pieprasÄ«jumÄ iegÅ«stam ctx - contekstu, kas Ä¼auj sazinÄties ar db.

Pilns funkciju fails todo.Ts (viens GET pieprasijums un 5 mutÄcijas) :

import { ConvexError, v } from "convex/values";
import { mutation, query } from "../convex/_generated/server";

//iegÅ«stam todos no db

export const getTodos = query({
    handler: async (ctx) => {
        const todos = await ctx.db.query("todos").order("desc").collect();
        return todos;
    }
});

// todo pievienoshanas funkcija

export const addTodo = mutation({
    args: { text: v.string() },
    handler: async (ctx, args) => {
        const todoId = await ctx.db.insert("todos", {
            text: args.text,
            isCompleted: false
        });
        return todoId;
    }
});


// pÄrslÄ“gs pogai - ir vai nav todo

export const toggleTodo = mutation({
    args: { id: v.id("todos") },
    handler: async (ctx, args) => {
        const todo = await ctx.db.get(args.id);
        if (!todo) {
            throw new ConvexError("Todo not found");
        }
        await ctx.db.patch(args.id, {
            isCompleted: !todo.isCompleted
        });
    }
})

// todo dzÄ“Å¡anas funkcija

export const deleteTodo = mutation({
    args: { id: v.id("todos") },
    handler: async (ctx, args) => {
        await ctx.db.delete(args.id);
    }
})

// todo rediÄ£Ä“Å¡anas funkcija

export const updateTodo = mutation({
    args: { id: v.id("todos"), text: v.string() },
    handler: async (ctx, args) => {
        await ctx.db.patch(args.id, {
            text: args.text
        });
    }
})

// reset app btn funkcija (visi todos tiek dzÄ“sti)

export const clearAllTodos = mutation({
    handler: async (ctx) => {
        const todos = await ctx.db.query("todos").collect();


        //Delete all todos
        for (const todo of todos) {
            await ctx.db.delete(todo._id);
        }

        return { deleteCount: todos.length };
    }
})

*************************** 
https://www.youtube.com/watch?v=jdfNnNccDt0
From 1:10:00 - 1:14:27
Add functions to app
****************************

1. ImportÄ“jam app/_layout.tsx failÄ ConvexProvider un ConverReactClient. un ietinam visu layoutu ieksh convex provider, lai visa app bÅ«tu saistÄ«ta ar convex. Pilns kods: 

import { ConvexProvider, ConvexReactClient } from "convex/react";
import { Stack } from "expo-router";
import React from "react";
import { ThemeProvider } from "../hooks/useTheme";

const convex = new ConvexReactClient(process.env.EXPO_PUBLIC_CONVEX_URL!, {
  unsavedChangesWarning: false,
});

export default function RootLayout() {
  return (
    <ConvexProvider client={convex}>
      <ThemeProvider>
        <Stack screenOptions={{
          headerShown: false,
        }}>
          <Stack.Screen name="(tabs)" />
        </Stack>
      </ThemeProvider>
    </ConvexProvider>
  );
}

2. Pievienojam datus no DB uz index screenu tab/index.tsx failÄ.

import { useQuery } from 'convex/react'
import { api } from '../../convex/_generated/api'


export default function Index() {
    const { toggleDarkMode } = useTheme()

    const todos = useQuery(api.todo.getTodos)
    console.log(todos)

    return (.......

// ieguustam tukshu masiivu jo nav veel neviens todo izveidots.

3. Pievienojam nepiecieÅ¡aaas mutÄcija, kuras pÄ“c tam izsaulsim ar touchableopacity :

    const todos = useQuery(api.todo.getTodos)
    console.log(todos)

    const addTodo = useMutation(api.todo.addTodo)

    const clearAllTodos = useMutation(api.todo.clearAllTodos)

    // un izsauc tÄs at touchableopacity:

   <TouchableOpacity onPress={() => addTodo({ text: "New Todo" })}>
                <Text>Add Todo</Text>
            </TouchableOpacity>
            <TouchableOpacity onPress={() => clearAllTodos()}>
                <Text>Clear All Todos</Text>
            </TouchableOpacity>


*************************** 
https://www.youtube.com/watch?v=jdfNnNccDt0
From 1:14:27
Setting up styles & Header component
****************************

1. ja mums ir divas tÄ“mas -gaiÅ¡Ä un tumÅ¡Ä, tad krÄsas butu logiski ieviest vadoties no tÄ“mas. MÄ“s varam const styles papildinÄt ar backgroundColor: colors.background, color: colors.text, bet varam to visu "wrapot" funkcijÄ.

2. izdzÄ“Å¡am no indeksa visu const styles,  un tÄ vietÄ uzrakstÄm funkciju - piem:
lai to "ieviestu" izveidojam: const styles = createStyles(colors) un tajÄ "wrapojam" veco const styles.

viss kods: 

import React from 'react';
import { StyleSheet, Text, TouchableOpacity, View } from 'react-native';
import useTheme, { ColorScheme } from '../../hooks/useTheme';

export default function Index() {
    const { toggleDarkMode, colors } = useTheme()

    const styles = createStyles(colors);

    return (
        <View style={styles.container}>
            <Text style={styles.text}>Index</Text>
            <TouchableOpacity onPress={toggleDarkMode}>
                <Text style={styles.text}>Toggle Mode</Text>
            </TouchableOpacity>
        </View>
    )
}

const createStyles = (colors: ColorScheme) => {      // colorScheme from hooks folder
    return StyleSheet.create({
        container: {
            flex: 1,
            alignItems: 'center',
            justifyContent: 'center',
            padding: 10,
            backgroundColor: colors.bg,
        },
        text: {
            color: colors.text,
        }
    });
};

// izveidojam assets/styles/home.styles.ts - tajÄ bÅ«s funkcijÄ wrapoti stili un failu settings.styles.ts - tas praktiski ir appa ui. Tagad indx failÄ iepriekÅ¡ izveidotu const styles = createStyles(colors) varam dzÄ“st pilnÄ«bÄ, tÄ vairs nav vajadzÄ«ga un krÄsu ievieÅ¡anu index failÄ pielabojam uz - const homeStyles = createHomeStyles(colors), ari importÄ“jam to no import { createHomeStyles } from '@/assets/styles/home.styles';
un stilus return selcijÄ nomainam no styles uz homeStyles.

3. Lai teksti "neaizbrauc" lietojam SafeAreaView parastÄ View vietÄ. importÄ“jam no - import {SafeAreaView} from "react-native-safe-area-context" , arÄ« saSafeAreaView  stilu nomainam uz homeStyles.safeArea - jo tas ir definÄ“ts iepriekÅ¡ izveidotajos ui failos ka atseviÅ¡Ä·s stils.

4. lai stilizÄ“tu katra todo fonu izmantojam self-closed componentu -  Expo Linear Gradient
npx expo install expo-linear-gradient

- hookos useTheme.tsx mums ir gradientu krÄsas definÄ“tas.

5. Pielietojam linear gradientu - ietinam index safeAreaView ieksh <LinearGradient colors={colors.gradients.background} style={homeStyles.container}> un importjam to - import { LinearGradient } from 'expo-linear-gradient'; krÄsas gradientÄ var mainÄ«t hookos teemas krÄsÄs definÄ“tajÄs gradient krÄsÄs.

6. Tagad headeris. lai tas mainiitos - gaish tumshajÄ tÄ“mÄ un tumsh gaiÅ¡ajÄ tÄ“mÄ - izmanto statusBar komponentu. To ievieto pirms gradienta un visu return kodu iewrapo rect fragmentaa <></>
<StatusBar barStyle={colors.statusBarStyle} />  //dinamiski maina krÄsu
import { StatusBar } from 'react-native';





