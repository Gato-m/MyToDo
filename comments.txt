ToDo - tips:

*************************** 
https://www.youtube.com/watch?v=jdfNnNccDt0
Till 40:23
Tab navigation, tabBar stylize, tabBar icons are done
****************************

1. Why Tabs is not styling by StyleSheet?

2. Icons - Ionicons from expo-router

3. Icon size={size} color={color}. Why?

*************************** 
https://www.youtube.com/watch?v=jdfNnNccDt0
From 40:23 till 53:28
Dark and Light mode
****************************

!!!!! TypeScript interfeisu lietoÅ¡ana ReactNative
!!!!! Context API lietoÅ¡ana ReactNative
!!!!! Provider lietoÅ¡ana ReactNative
!!!!! useContext lietoÅ¡ana ReactNative
!!!!! useState lietoÅ¡ana ReactNative
!!!!! useEffect lietoÅ¡ana ReactNative
!!!!! asyncStorage lietoÅ¡ana ReactNative


1. Local Storage - lai atcereetos kÄdu tÄ“mu izvÄ“lÄ“jÄs lietotÄjs.

2. To nodroÅ¡ina speciÄls hook(s)

3. Local storage vietÄ izmantojam async-storage

npm i @react-native-async-storage/async-storage

4. jÄizveido themeProvider (fails ar 132 rindÄm koda tÄ«rÄ React ar Typescript un nekÄ no ReactNative, izÅ†emot async-storage pakotni). 
- importÄ“jam useState, useEffect un asyncStorage.
- Providerim ir useState - kas seko kÄds reims izvÄ“lÄ“ts
- useEffect - lai iegaumÄ“tu lietotÄja izvÄ“li pÄ“dÄ“jÄ sistÄ“mas palaiÅ¡anas reizÄ“.
- tad tiek izsaukta metode toggleDarkMode - kas Ä¼auj pÄrslÄ“gt tÄ“mas un atjauno asyncStorage noglabÄtos datus (Dark modÄ“ izmantojam agrÄk nodefinÄ“tÄs tumÅ¡Äs krÄsas, Ligh ModÄ“ - gaiÅ¡Äs).
- Lai to nodroÅ¡inÄtu izveidojam hooku useTheme, kurÅ¡ izsauc context.
- const useTheme = () => {
    const context = useContext(ThemeContext);
    if (context === undefined) {
        throw new Error("useTheme must be used within a ThemeProvider");
    }

    return context;
};

5. Tagad pamata _layoutÄ (ne tab layoutÄ) viss kods jÄietin (wrap), lai varÄ“tu izmantot Light un Dark modes. 

6. Ietinam visu ThemeProviderÄ« (ko importÄ“jam nevis no react-native, bet no ../hooks/useTheme)

import { Stack } from "expo-router";
import { ThemeProvider } from "../hooks/useTheme";
import React from "react";

export default function RootLayout() {
  return (
    <ThemeProvider>
      <Stack screenOptions={{
        headerShown: false,
      }}>
        <Stack.Screen name="(tabs)" />
      </Stack>
    </ThemeProvider>
  );
}

7. Tagad pielabojam (tabs) screenus,lai izmantotu themes nodefinÄ“tÄs krÄsas (color={color} etc.).
....
import { useTheme } from '../../hooks/useTheme';

  <Tabs screenOptions={{
            tabBarActiveTintColor: colors.primary,
            tabBarInactiveTintColor: colors.textMuted,
            tabBarStyle: {
                backgroundColor: colors.surface,
                borderTopWidth: 1,
                borderTopColor: colors.border,
.......

app lieto LightMode, jo hookaa useTheme useState sÄkumstÄvoklis ir false, bet     const colors = isDarkMode ? darkColors : lightColors;
tÄtad sÄkumÄ sanÄk light Mode.

8. Pievienojam tÄ“mu pÄrslÄ“gÅ¡anas toggle pogu (pÄrbaudam - tabBar maina tÄ“mu. PÄrstartÄ“jot app, tÄ“ma ir tÄ,kas bija pirms app aizvÄ“rÅ¡anas jo stÄvooklis saglabÄjas async storage (local - iekÄrtÄ kurÄ instalÄ“ta app)) - importÄ“jam hooku, pievienojam no hooka toggleDarkMode metodi un uzrakstam uzrakstu "Toggle Mode"

import React from 'react'
import { StyleSheet, Text, View, TouchableOpacity } from 'react-native'
import useTheme from '../../hooks/useTheme'

export default function Index() {
    const { toggleDarkMode } = useTheme()

    return (
        <View style={styles.container}>
            <Text>Index</Text>
            <TouchableOpacity onPress={toggleDarkMode}>
                <Text>Toggle Mode</Text>
            </TouchableOpacity>
        </View>
    )
}

Tagad tÄ“mu pÄrslÄ“gÅ¡ana darbojas, to vÄ“lÄk realizÄ“sim ar atseviÅ¡ku pÄrslÄ“gÅ¡anas komponentu setting screenÄ.

*************************** 
https://www.youtube.com/watch?v=jdfNnNccDt0
From 53:28 till 1:10:00
Add DataBase and configure schema and functions
****************************

1. izmantojam backendam Convex (lÄ«dz 20 projektiem - bez maksas)  (var Firebase vai Supabase)- the backend AI  (DB, autentifikÄcija, fona uzdevumi un citas funkcijas)

2. Projektu ConvexÄ var izveidot convex admin paneli vai no IDE terminÄÄ¼a:
- vienÄ terminÄlÄ« palaists npx expo
- otrÄ terminÄlÄ« -   npm i convex
tad -   npx convex dev

3. convex mapÄ“ izveido schema.ts failu. tad tajÄ izveido db tabulu sheemu.

import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
    todos: defineTable({
        text: v.string(),
        isCompleted: v.boolean(),
    }),
});


//PÄ“c schema.ts saglabÄÅ¡anas tev ir jÄizpilda:
bash
npx convex deploy
ğŸ‘‰ Å Ä« komanda:
augÅ¡upielÄdÄ“ shÄ“mu uz Convex backendu,
atjauno metadatus admin panelÄ«.
Ja tu esi tikai palaidis npx convex dev, tad shÄ“ma var bÅ«t lokÄli aktÄ«va, bet neparÄdÄs admin panelÄ«.

//Vai schema.ts satur export default defineSchema(...)?
Convex identificÄ“ shÄ“mu caur export default. Ja tu esi eksportÄ“jis to citÄdÄk (piemÄ“ram, export const schema = ...), tad tÄ netiks uzskatÄ«ta par aktÄ«vo shÄ“mu.
Pareizi bÅ«tu:
ts
import { defineSchema, defineTable } from "convex/schema";

export default defineSchema({
  klienti: defineTable({
    vÄrds: "string",
    e_pasts: "string",
    izveidots: "number",
  }),
});


// â—ï¸ SvarÄ«gi: jÄbÅ«t export default, nevis export const.

// pÄ“c DB pieslÄ“gÅ¡anas visu laiku JÄ€IZMANTO DIVI TERMINÄ€Ä»I VIENLAIKUS !!!!

VIENÄ€ - npx expo start
OTRÄ€ - npx convex dev // tas nodroÅ¡inÄs veikto izmaiÅ†u atjaunoÅ¡anu concex kontÄ.

*********************

convex mapÄ“ izveido failu todo.ts

// lai iegÅ«tu datus - sÅ«tam pieprasÄ«jumu (query )GET)
) uz db, lai rediÄ£Ä“tu vai dzÄ“stu ierakstu - jÄizmanto mutÄcija (createTodo, updateTodo, deleteTodo).

pieprasÄ«jumÄ iegÅ«stam ctx - contekstu, kas Ä¼auj sazinÄties ar db.

Pilns funkciju fails todo.Ts (viens GET pieprasijums un 5 mutÄcijas) :

import { ConvexError, v } from "convex/values";
import { mutation, query } from "../convex/_generated/server";

//iegÅ«stam todos no db

export const getTodos = query({
    handler: async (ctx) => {
        const todos = await ctx.db.query("todos").order("desc").collect();
        return todos;
    }
});

// todo pievienoshanas funkcija

export const addTodo = mutation({
    args: { text: v.string() },
    handler: async (ctx, args) => {
        const todoId = await ctx.db.insert("todos", {
            text: args.text,
            isCompleted: false
        });
        return todoId;
    }
});


// pÄrslÄ“gs pogai - ir vai nav todo

export const toggleTodo = mutation({
    args: { id: v.id("todos") },
    handler: async (ctx, args) => {
        const todo = await ctx.db.get(args.id);
        if (!todo) {
            throw new ConvexError("Todo not found");
        }
        await ctx.db.patch(args.id, {
            isCompleted: !todo.isCompleted
        });
    }
})

// todo dzÄ“Å¡anas funkcija

export const deleteTodo = mutation({
    args: { id: v.id("todos") },
    handler: async (ctx, args) => {
        await ctx.db.delete(args.id);
    }
})

// todo rediÄ£Ä“Å¡anas funkcija

export const updateTodo = mutation({
    args: { id: v.id("todos"), text: v.string() },
    handler: async (ctx, args) => {
        await ctx.db.patch(args.id, {
            text: args.text
        });
    }
})

// reset app btn funkcija (visi todos tiek dzÄ“sti)

export const clearAllTodos = mutation({
    handler: async (ctx) => {
        const todos = await ctx.db.query("todos").collect();


        //Delete all todos
        for (const todo of todos) {
            await ctx.db.delete(todo._id);
        }

        return { deleteCount: todos.length };
    }
})

*************************** 
https://www.youtube.com/watch?v=jdfNnNccDt0
From 1:10:00 - 1:14:27
Add functions to app
****************************

1. ImportÄ“jam app/_layout.tsx failÄ ConvexProvider un ConverReactClient. un ietinam visu layoutu ieksh convex provider, lai visa app bÅ«tu saistÄ«ta ar convex. Pilns kods: 

import { ConvexProvider, ConvexReactClient } from "convex/react";
import { Stack } from "expo-router";
import React from "react";
import { ThemeProvider } from "../hooks/useTheme";

const convex = new ConvexReactClient(process.env.EXPO_PUBLIC_CONVEX_URL!, {
  unsavedChangesWarning: false,
});

export default function RootLayout() {
  return (
    <ConvexProvider client={convex}>
      <ThemeProvider>
        <Stack screenOptions={{
          headerShown: false,
        }}>
          <Stack.Screen name="(tabs)" />
        </Stack>
      </ThemeProvider>
    </ConvexProvider>
  );
}

2. Pievienojam datus no DB uz index screenu tab/index.tsx failÄ.

import { useQuery } from 'convex/react'
import { api } from '../../convex/_generated/api'


export default function Index() {
    const { toggleDarkMode } = useTheme()

    const todos = useQuery(api.todo.getTodos)
    console.log(todos)

    return (.......

// ieguustam tukshu masiivu jo nav veel neviens todo izveidots.

3. Pievienojam nepiecieÅ¡aaas mutÄcija, kuras pÄ“c tam izsaulsim ar touchableopacity :

    const todos = useQuery(api.todo.getTodos)
    console.log(todos)

    const addTodo = useMutation(api.todo.addTodo)

    const clearAllTodos = useMutation(api.todo.clearAllTodos)

    // un izsauc tÄs at touchableopacity:

   <TouchableOpacity onPress={() => addTodo({ text: "New Todo" })}>
                <Text>Add Todo</Text>
            </TouchableOpacity>
            <TouchableOpacity onPress={() => clearAllTodos()}>
                <Text>Clear All Todos</Text>
            </TouchableOpacity>


*************************** 
https://www.youtube.com/watch?v=jdfNnNccDt0
From 1:14:27 - 1:34:20
Setting up styles & Header component
****************************

1. ja mums ir divas tÄ“mas -gaiÅ¡Ä un tumÅ¡Ä, tad krÄsas butu logiski ieviest vadoties no tÄ“mas. MÄ“s varam const styles papildinÄt ar backgroundColor: colors.background, color: colors.text, bet varam to visu "wrapot" funkcijÄ.

2. izdzÄ“Å¡am no indeksa visu const styles,  un tÄ vietÄ uzrakstÄm funkciju - piem:
lai to "ieviestu" izveidojam: const styles = createStyles(colors) un tajÄ "wrapojam" veco const styles.

viss kods: 

import React from 'react';
import { StyleSheet, Text, TouchableOpacity, View } from 'react-native';
import useTheme, { ColorScheme } from '../../hooks/useTheme';

export default function Index() {
    const { toggleDarkMode, colors } = useTheme()

    const styles = createStyles(colors);

    return (
        <View style={styles.container}>
            <Text style={styles.text}>Index</Text>
            <TouchableOpacity onPress={toggleDarkMode}>
                <Text style={styles.text}>Toggle Mode</Text>
            </TouchableOpacity>
        </View>
    )
}

const createStyles = (colors: ColorScheme) => {      // colorScheme from hooks folder
    return StyleSheet.create({
        container: {
            flex: 1,
            alignItems: 'center',
            justifyContent: 'center',
            padding: 10,
            backgroundColor: colors.bg,
        },
        text: {
            color: colors.text,
        }
    });
};

// izveidojam assets/styles/home.styles.ts - tajÄ bÅ«s funkcijÄ wrapoti stili un failu settings.styles.ts - tas praktiski ir appa ui. Tagad indx failÄ iepriekÅ¡ izveidotu const styles = createStyles(colors) varam dzÄ“st pilnÄ«bÄ, tÄ vairs nav vajadzÄ«ga un krÄsu ievieÅ¡anu index failÄ pielabojam uz - const homeStyles = createHomeStyles(colors), ari importÄ“jam to no import { createHomeStyles } from '@/assets/styles/home.styles';
un stilus return selcijÄ nomainam no styles uz homeStyles.

3. Lai teksti "neaizbrauc" lietojam SafeAreaView parastÄ View vietÄ. importÄ“jam no - import {SafeAreaView} from "react-native-safe-area-context" , arÄ« saSafeAreaView  stilu nomainam uz homeStyles.safeArea - jo tas ir definÄ“ts iepriekÅ¡ izveidotajos ui failos ka atseviÅ¡Ä·s stils.

4. lai stilizÄ“tu katra todo fonu izmantojam self-closed componentu -  Expo Linear Gradient
npx expo install expo-linear-gradient

- hookos useTheme.tsx mums ir gradientu krÄsas definÄ“tas.

5. Pielietojam linear gradientu - ietinam index safeAreaView ieksh <LinearGradient colors={colors.gradients.background} style={homeStyles.container}> un importjam to - import { LinearGradient } from 'expo-linear-gradient'; krÄsas gradientÄ var mainÄ«t hookos teemas krÄsÄs definÄ“tajÄs gradient krÄsÄs.

6. Tagad headeris. lai tas mainiitos - gaish tumshajÄ tÄ“mÄ un tumsh gaiÅ¡ajÄ tÄ“mÄ - izmanto statusBar komponentu. To ievieto pirms gradienta un visu return kodu iewrapo rect fragmentaa <></>
<StatusBar barStyle={colors.statusBarStyle} />  //dinamiski maina krÄsu
import { StatusBar } from 'react-native';

6. SÄkam veidot pirmÄ screena satura komponentus.

Component folderÄ« Header.tsx failÄ <Header />

- kÄ progressBar procentus sarÄ“Ä·inÄt?

    const todos = useQuery(api.todos.getTodos);

    const completedCount = todos ? todos.filter((todo) => todo.isCompleted).length : 0;
    const totalCount = todos ? todos.length : 0;
    const progressPercentage = totalCount > 0 ? (completedCount / totalCount) * 100 : 0;

// pilns header code Å¡ajÄ bridÄ«:

import { createHomeStyles } from "@/assets/styles/home.styles";
import { api } from "@/convex/_generated/api";
import useTheme from "@/hooks/useTheme";
import { Ionicons } from "@expo/vector-icons";
import { useQuery } from "convex/react";
import { LinearGradient } from "expo-linear-gradient";
import { Text, View } from "react-native";

const Header = () => {
    const { colors } = useTheme();
    const homeStyles = createHomeStyles(colors);

    const todos = useQuery(api.todo.getTodos);

    const completedCount = todos ? todos.filter((todo) => todo.isCompleted).length : 0;
    const totalCount = todos ? todos.length : 0;
    const progressPercentage = totalCount > 0 ? (completedCount / totalCount) * 100 : 0;

    return (
        <View style={homeStyles.header}>
            <View style={homeStyles.titleContainer}>
                <LinearGradient colors={colors.gradients.primary} style={homeStyles.iconContainer}>
                    <Ionicons name="flash-outline" size={28} color="#fff" />
                </LinearGradient>

                <View style={homeStyles.titleTextContainer}>
                    <Text style={homeStyles.title}>Today&apos;s Tasks  ğŸ‘€</Text>
                    <Text style={homeStyles.subtitle}>
                        {completedCount} of {totalCount} completed
                    </Text>
                </View>
            </View>

            <View style={homeStyles.progressContainer}>
                <View style={homeStyles.progressBarContainer}>
                    <View style={homeStyles.progressBar}>
                        <LinearGradient
                            colors={colors.gradients.success}
                            style={[homeStyles.progressFill, { width: `${progressPercentage}%` }]}
                        />
                    </View>
                    <Text style={homeStyles.progressText}>{Math.round(progressPercentage)}%</Text>
                </View>
            </View>
        </View>
    );
};

export default Header;

*************************** 
https://www.youtube.com/watch?v=jdfNnNccDt0
From 1:34:20 - 1:43:45
Add todos component <TodoInput />
****************************

1. nodroÅ¡inam stilizÄciju atbilstoÅ¡i tÄ“mai. IegÅ«stam colores no custom hook useTheme, stilus no metodes createHomeStyles(colors) kas nosaka home screen stilus.

- importÄ“jam;
import { createHomeStyles } from '@/assets/styles/home.styles'
import useTheme from '@/hooks/useTheme'

un kodÄ:

export default function TodoInput() {
    const { colors } = useTheme();
    const homeStyles = createHomeStyles(colors);
    ...

2. KomponentÄ izmantosim mutÄciju.
vispirms iegustam esoÅ¡o stÄvokli, tad mutÄcija, kas Ä¼auj radÄ«t jaunus todo (importÄ“jam mutÄciju un api no convex):

const [newTodo, setNewTodo] = useState('')
const addTodo = useMutation(api.todo.addTodo)

3. izveidojam lietotaaja ui, un radam funkciju handleAddTodo, kas izsauks funkciju addTodo, kad ir ievadits todo un nospiests enter:

const handleAddTodo = async() => {}

tad pievienojam TextInput:
     <TextInput
                    style={homeStyles.input}
                    placeholder="Add new todo"
                    value={newTodo}
                    onChangeText={setNewTodo}
                    onSubmitEditing={handleAddTodo}
                    multiline
                    placeholderTextColor={colors.textMuted}
                />

     - onSubmitEditing={handleAddTodo} - nospiests enter  - nosÅ«ta mutÄciju un pievieno jaunu todo un ar (onChangeText={setNewTodo}) atjauno useState - setNewTodo('')           

//////   !!!!!!!!  Cmd + K - izsauc ekrÄna klaviaturu)

4. PagaidÄm Enter nospieÅ¡ana uz klaviatÅ«ras izveido jaunu rindkopu iekÅ¡h TextInput.
Tas jÄlabo - aizvÄcam multiline opciju un Enter strÄdÄ nosÅ«tot mutÄciju.

5. Pievienojam pogu "Add" kas nosÅ«ta mutÄciju un pievieno jaunu todo. 
pogas fonÄ - linear gradient, teksta vietÄ icona, abi maina savu stilu atkarÄ«ba no newTodo.trim() - ja ir ievadits todo un nospiests enter, tad pogas fon ir primary, ja nav ievadits todo, tad pogas fon ir muted.

                <TouchableOpacity onPress={handleAddTodo} activeOpacity={0.8} disabled={!newTodo.trim()}>
                <LinearGradient colors={newTodo.trim() ? colors.gradients.primary : colors.gradients.muted} style={[homeStyles.addButton, !newTodo.trim() ? homeStyles.addButtonDisabled ]}>
                    <Ionicons name="add" size={24} color="#fff" />
                </LinearGradient>
                </TouchableOpacity>


6. NodroÅ¡inÄm pÄrbaudi ievadot jaunu todo - ja ir ievadÄ«ts jauns todo - tad to pievienojam, ja ne - tad funkcija handleAddTodo nestrÄdas, pievienojam arÄ« trim() - lai noÅ†emtu tukÅ¡as rakstzÄ«mes, lai neaizsÅ«t tikai tukÅ¡umu mutÄcijÄ.
TÄpÄ“c arÄ« nospieÅ¡ot pievienot jaunu todo neizsaucam pa tieÅ¡o mutÄcijas funkciju addTodo, bet wrapojam to citÄ funkcijÄ handleAddTodo. Tas Ä¼auj veikt ievades pÄrbaudi - try catch blokÄ.
App nav jaatjauno lai redzÄ“tu vai todo pievienojies, to nodroÅ¡ina funlcija  const todos = useQuery(api.todo.getTodos) no componenta header - convex caur socket atsÅ«ta nepiecieÅ¡amos datus - tas strÄdÄ real time from the box. 

*************************** 
https://www.youtube.com/watch?v=jdfNnNccDt0
From 1:43:50 - 2:01:20
Show Todos at home screen as FlatList
****************************

1. Var importÄ“t api, izmantot GET pieprasÄ«jumu (const todos = useQuery(api.todo.getTodos) un saÅ†emt visus todo no db un tad tos parÄdÄ«t home screenÄ. Tad izmantojam 
{todos?.map((todo) => <Text key={todo._id}>{todo.text}</Text>)}
un iegÅ«stam visu todo sarakstu.

2. EfektÄ«vÄks Å¡ÄdÄ gadÄ«jumÄ ir FlatList komponents. jo map gadÄ«jumÄ ielÄdÄ“jot screenu tiek renderÄ“ti visi simts todo, arÄ« tie, kas ir "aiz kadra" , flatlist gadÄ«jumÄ tiek renderÄ“ti tikai tie kas redzami ekrÄnÄ. parÄ“jie tiek renderÄ“ti pie scrolla... tas ir efektÄ«vÄk. Ja zinÄms ka saraksts neliels - var izmantot arÄ« map, ja nav - flatlist.

3. Ja nezinÄm cik garÅ¡ ir saraksts un cik Ätri tas ielÄdÄ“sies ir jÄ“ga pievienot ielÄdes komponentu. Ja datu ielÄde no convex ir procesÄ un nav pabeigta - consolÄ“ rÄda undefined - tÄtad atrodamies isLoading stÄvoklÄ«, pretÄ“jÄ gadÄ«jumÄ - false.

const isLoading = todos === undefined

- izveidojam komponentu LoadingSpinner:

import { createHomeStyles } from "@/assets/styles/home.styles";
import useTheme from "@/hooks/useTheme";
import { LinearGradient } from "expo-linear-gradient";
import { ActivityIndicator, Text, View } from "react-native";

const LoadingSpinner = () => {
    const { colors } = useTheme();

    const homeStyles = createHomeStyles(colors);

    return (
        <LinearGradient colors={colors.gradients.background} style={homeStyles.container}>
            <View style={homeStyles.loadingContainer}>
                <ActivityIndicator size="large" color={colors.primary} />
                <Text style={homeStyles.loadingText}>Loading your todos...</Text>
            </View>
        </LinearGradient>
    );
};

export default LoadingSpinner;


- tad ieimportÄ“jam to index failÄ un ievietojam kodÄ. varam pÄrbaudÄ«t, ja to "ieslÄ“dzam" kodu :
    if (isLoading) return <LoadingSpinner />
aizvietojam ar 
    if (true) return <LoadingSpinner />

 4. pÄrejam pie FlatList.
 pirmais parametrs - datu masÄ«vs
 otrais - funkcija kas renderÄ“ katru todo. jÄrenderÄ“ tieÅ¡i elements (item) nevis todo.

 renderItem={({ item }) => <Text key={item._id}>{item.text}</Text>}

  - tagad Å¡o funkcijas kodu var ievietot jaunizveidotajÄfunkcijÄ renderTodoItem, kurÄ izmantojam importÄ“tÄ dokumenta datu tipu Todo kas nÄk no Convex:

// type Todo = {
//     _id: string;
//     text: string;
//     isCompleted: boolean;
// }

to rakstam kÄ: 
import { Doc } from '@/convex/_generated/dataModel';

type Todo = Doc<todos>

// tÄ var iegÅ«t datu tipu no Convex
// tagad funkcija datu attÄ“loÅ¡anai FlatListÄ:

const renderTodoItem = ({ item }: (item: Todo)) => {
    return (
        <View style={homeStyles.todoItem}>
            <Text style={homeStyles.todoText}>{item.text}</Text>
        </View>
    )
}

viss FlatList. key - katra todo identifikators, style - todo elementa stils, containerStyle - todo kontainera stils:

                    <FlatList
                        data={todos}
                        renderItem={renderTodoItem}
                        keyExtractor={(item) => item._id}
                        style={homeStyles.todoList}
                        contentContainerStyle={homeStyles.todoListContent}
                        showsVerticalScrollIndicator={false}
                    />

5.  Katra todo elementa stils ir todoItemWrapper un todoItem. todoItemWrapper ir linear gradient, todoItem ir todo elementa stils. todoText ir todo elementa teksts. Ja todo wrappera gradientu gribam pagriezt par 45 grÄdiem jÄsaprot ideja:

0/0 --------- 1    // x ass
    |       |
    |       |
    |       |
1   --------- 1/1
    y ass

gradients 45 grÄdu leÅ†Ä·Ä«:

<LinearGradient colors={colors.gradients.surface} 
    style={homeStyles.todoItem}
    start={{ x: 0, y: 0 }}
    end={{ x: 1, y: 1 }}
    >
</LinearGradient>

6. Tatad kopÄ katra todo wrapperis ar 45 grÄdu gradientu un apaÄ¼u pogu, kurÄ chekot vai todo ir pabeigts un ja ir pabeigts - tad pogas krÄsa ir success, ja nav pabeigts - tad pogas krÄsa ir muted un, ja pabeigts - tad checked ikona ir visible. Pilns kods:

const renderTodoItem = ({ item }: { item: Todo }) => {
        return (
            <View style={homeStyles.todoItemWrapper}>
                <LinearGradient colors={colors.gradients.surface}
                    style={homeStyles.todoItem}
                    start={{ x: 0, y: 0 }}
                    end={{ x: 1, y: 1 }}
                >
                    <TouchableOpacity
                        style={homeStyles.checkbox}
                        activeOpacity={0.7}
                        onPress={() => { }}>
                        <LinearGradient
                            colors={item.isCompleted ? colors.gradients.success : colors.gradients.muted}
                            style={[homeStyles.checkboxInner, { borderColor: item.isCompleted ? "transparent" : colors.border }]}
                        >
                            {item.isCompleted && <Ionicons name="checkmark" size={24} color="white" />}
                        </LinearGradient>
                    </TouchableOpacity>
                    <Text style={homeStyles.todoText}>{item.text}</Text>
                </LinearGradient >
            </View >
        )
    }


7. veidojam funkciju handleToggleTodo - kas izsauc mutÄciju updateTodo un pievieno todo id un ja todo ir pabeigts - tad pievieno true, ja nav pabeigts - tad pievieno false

    const handleToggleTodo = async (id: Id<"todos">) => {.....

// var jau id tipu norÄdÄ«t kÄ stringu, bet
lai typescript nelamÄtos, mums vajag importÄ“t Id no convex:
import { Id } from "@/convex/_generated/dataModel";

pirms pÄrslÄ“gt todo stÄvokli nosakÄm, ka ja todo ir pabeigts - tad pievieno true, ja nav pabeigts - tad pievieno false (tas jau ir noteikts convex db ar funkciju toggleTodo). TÄpÄ“c lietojam mutÄciju kÄ api - tas atcels todo esoÅ¡o stÄvokli. Tad funkcijÄ catch blokÄ ieliekampazinojumu, ja neizdevÄs pÄrslÄ“gt esoÅ¡o stÄvokli.

    const toggleTodo = useMutation(api.todo.toggleTodo);

    const handleToggleTodo = async (id: Id<"todos">) => {
        try {
            await toggleTodo({ id });
        } catch (error) {
            console.log("Error toggling todo", error);
            Alert.alert("Error", "Failed to toggle todo");
        }
    };

8. NoformÄ“jam katra todo teksta stilu - ja todo ir pabeigts - tad teksts ir line-through, ja nav pabeigts - tad teksts ir normals. Tas viss ieksh atsevishkja View containera:

    <View style={homeStyles.todoTextContainer}>
                        <Text
                            style={[homeStyles.todoText,
                            item.isCompleted && {
                                textDecorationLine: "line-through",
                                color: colors.textMuted,
                                opacity: 0.6,
                            },]} >
                            {item.text}</Text>
                    </View>

9,. tagad katram todo texta blokam jÄpievieno divas pogas - edit un delete.

<View style={homeStyles.todoActions}>
                <TouchableOpacity onPress={() => handleEditTodo(item)} activeOpacity={0.8}>
                  <LinearGradient colors={colors.gradients.warning} style={homeStyles.actionButton}>
                    <Ionicons name="pencil" size={14} color="#fff" />
                  </LinearGradient>
                </TouchableOpacity>
                <TouchableOpacity onPress={() => handleDeleteTodo(item._id)} activeOpacity={0.8}>
                  <LinearGradient colors={colors.gradients.danger} style={homeStyles.actionButton}>
                    <Ionicons name="trash" size={14} color="#fff" />
                  </LinearGradient>
                </TouchableOpacity>
              </View>

10. Vel vienanianse - kas notiek, ja todo masÄ«vs bus tukÅ¡s. Tad var izmantot 
 - ListEmptyComponent={<EmptyState />}

izveidojam EmptyState komponentu: 

import { createHomeStyles } from "@/assets/styles/home.styles";
import useTheme from "@/hooks/useTheme";
import { Ionicons } from "@expo/vector-icons";
import { LinearGradient } from "expo-linear-gradient";
import { Text, View } from "react-native";

const EmptyState = () => {
  const { colors } = useTheme();

  const homeStyles = createHomeStyles(colors);

  return (
    <View style={homeStyles.emptyContainer}>
      <LinearGradient colors={colors.gradients.empty} style={homeStyles.emptyIconContainer}>
        <Ionicons name="clipboard-outline" size={60} color={colors.textMuted} />
      </LinearGradient>
      <Text style={homeStyles.emptyText}>No todos yet!</Text>
      <Text style={homeStyles.emptySubtext}>Add your first todo above to get started</Text>
    </View>
  );
};
export default EmptyState;


*************************** 
https://www.youtube.com/watch?v=jdfNnNccDt0
From 2:01:20 - 2:05:13
Delete todos functionality
****************************

1. Delete todos. 

- izveidojam jaunu api mutÄciju un saglabÄjam mainÄ«gajÄ deleteTodo:
        const deleteTodo = useMutation(api.todo.deleteTodo);

- un izsaucam to ar handleDeleteTodo funkciju:
// vÄ“l viena fiÅ¡ka - pirms dzÄ“Å¡anas parÄdÄs alert logs ar komandu (Delete Todo) un divÄm izvÄ“lÄ“m - dzÄ“st vai nedzÄ“st Å¡o todo. katra izvÄ“le - cancel iun delete ir atseviÅ¡Ä·s objekts masÄ«vÄ kas ir iekÄ¼auts alert logÄ.


    const handleDeleteTodo = async (id: Id<"todos">) => {

        Alert.alert("Delete Todo", "Are you sure you want to delete this todo?", [
            {
                text: "Cancel",
                onPress: () => console.log("Cancel Pressed"),
                style: "cancel",
            },
            {
                text: "Delete",
                style: "destructive",
                onPress: () => deleteTodo({ id }),
            },
        ]);
    };

*************************** 
https://www.youtube.com/watch?v=jdfNnNccDt0
From 2:05:13 - 2:14:01
Edit todos functionality
****************************

1. Edit todo. AttiecÄ«gÄ todo wrapperÄ« funkcija handleEditTodo mainÄ«si interfeisa daÄ¼u - parÄdÄ«sies editÄ“jams inputs un divas pogas - save (atceÄ¼ iepriekÅ¡Ä“jo stÄvokli) un cancel (atceÄ¼ darbÄ«bu). TÄtad vajadzÄ«gi divi stÄvokÄ¼i - viens todo rediÄ£Ä“Å¡anas id un otrs - rediÄ£Ä“jamÄ todo teksts. lai atjaunotu tikai to, kas nepiecieÅ¡ams nepiecieÅ¡ams izmantot redigÄ“Å¡anas id.

2. Tagad varam dzÄ“st ieprikÅ¡ lietoto toggleTodo metodi un izmantot useState hooku.

const updateTodo = useMutation(api.todo.updateTodo);

const [editingId, setEditingId] = useState<Id<"todos"> | null>(null);
const [editText, setEditText] = useState<string>("");

// tagad funkcijas: handleEditTodo atrod labojamÄ todo id un tekstu, const handleSaveEdit - Ä¼auj labot todo, const handleCancelEdit - atceÄ¼ rediÄ£Ä“Å¡anu :

   const handleEditTodo = (todo: Todo) => {
        setEditingId(todo._id)
        setEditText(todo.text)
    }
    const handleSaveEdit = async () => {
        if (editingId) {
            try {
                await updateTodo({ id: editingId, text: editText.trim ()})
                setEditingId(null)
                setEditText("")
            } catch (error) {
                console.log("Error updating todo", error)
                Alert.alert("Error", "Failed to update todo")
            }
        }
        const handleCancelEdit = () => {
            setEditingId(null)
            setEditText("")
        }
    }

3. tagad var izsaukt tikko izveidotÄs funkcija lietotaaja interfeisÄ, bet mums nav Å¡Ä« stÄvokÄ¼a. TÄpÄ“c atrodam katra todo wrappera text container ( kurÄ gatavojamies veikt izmaiÅ†as )

/////////// Vispirms pielabojam renderTodoItem funkciju un nosakÄm kad tiks pÄrrenderÄ“ts ToDo:

 const renderTodoItem = ({ item }: { item: Todo }) => {
        const isEditing = editingId === item._id
        return (.........

///////////  Bija: 

<View style={homeStyles.todoTextContainer}>
                        <Text
                            style={[homeStyles.todoText,
                            item.isCompleted && {
                                textDecorationLine: "line-through",
                                color: colors.textMuted,
                                opacity: 0.6,
                            },]} >
                            {item.text}</Text>

                        <View style={homeStyles.todoActions}>
                            <TouchableOpacity onPress={() => handleEditTodo(item)} activeOpacity={0.8}>
                                <LinearGradient colors={colors.gradients.warning} style={homeStyles.actionButton}>
                                    <Ionicons name="pencil" size={14} color="#fff" />
                                </LinearGradient>
                            </TouchableOpacity>
                            <TouchableOpacity onPress={() => handleDeleteTodo(item._id)} activeOpacity={0.8}>
                                <LinearGradient colors={colors.gradients.danger} style={homeStyles.actionButton}>
                                    <Ionicons name="trash" size={14} color="#fff" />
                                </LinearGradient>
                            </TouchableOpacity>
                        </View>
                    </View>
					
					
/////////// sÄkam interfeisa izmaiÅ†as:

editÄ“jamÄ todo containera textInput:

 isEditing ? (
                    <View style={homeStyles.editContainer}>
                        <TextInput
                            value={editText}
                            onChangeText={setEditText}
                            style={homeStyles.editInput}
                            autoFocus
                            multiline
                            placeholder="Edit todo"
                            placeholderTextColor={colors.textMuted}
                        />
                    </View>
                    ) : (
                    <View style={homeStyles.todoTextContainer}>...

///////////  nospieÅ¾ot redigÄ“Å¡anaspogu nekas nenotiek jo nav nodefinÄ“ta pogas funkcijas . pievienojam pogai funkciju handleEditTodo:

<TouchableOpacity onPress={() => handleEditTodo(item)} activeOpacity={0.8}>
					
.....
					
///////////   PÄ“c jaunÄ - edit stÄvokÄ¼a ievietoÅ¡anas pilns abu todo containeru kods (ar nosacÄ«jumu isediting):


                    {isEditing ? (
                        <View style={homeStyles.editContainer}>
                            <TextInput
                                value={editText}
                                onChangeText={setEditText}
                                style={homeStyles.editInput}
                                autoFocus
                                multiline
                                placeholder="Edit todo"
                                placeholderTextColor={colors.textMuted}
                            />

                            <View style={homeStyles.editButtons}>
                                <TouchableOpacity onPress={handleSaveEdit} activeOpacity={0.8}>
                                    <LinearGradient colors={colors.gradients.success} style={homeStyles.editButton}>
                                        <Ionicons name="checkmark" size={16} color="#fff" />
                                        <Text style={homeStyles.editButtonText}>Save</Text>
                                    </LinearGradient>
                                </TouchableOpacity>

                                <TouchableOpacity onPress={handleCancelEdit} activeOpacity={0.8}>
                                    <LinearGradient colors={colors.gradients.danger} style={homeStyles.editButton}>
                                        <Ionicons name="close" size={16} color="#fff" />
                                        <Text style={homeStyles.editButtonText}>Cancel</Text>
                                    </LinearGradient>
                                </TouchableOpacity>
                            </View>
                        </View>

                    ) : (
                        <View style={homeStyles.todoTextContainer}>
                            <Text
                                style={[homeStyles.todoText,
                                item.isCompleted && {
                                    textDecorationLine: "line-through",
                                    color: colors.textMuted,
                                    opacity: 0.6,
                                },]} >
                                {item.text}</Text>

                            <View style={homeStyles.todoActions}>
                                <TouchableOpacity onPress={() => handleEditTodo(item)} activeOpacity={0.8}>
                                    <LinearGradient colors={colors.gradients.warning} style={homeStyles.actionButton}>
                                        <Ionicons name="pencil" size={14} color="#fff" />
                                    </LinearGradient>
                                </TouchableOpacity>
                                <TouchableOpacity onPress={() => handleDeleteTodo(item._id)} activeOpacity={0.8}>
                                    <LinearGradient colors={colors.gradients.danger} style={homeStyles.actionButton}>
                                        <Ionicons name="trash" size={14} color="#fff" />
                                    </LinearGradient>
                                </TouchableOpacity>
                            </View>
                        </View>
                    )
                    }

                 
//////// nav iisti tÄ«rs un moderns kods, to var sadaliit komponentos vai izveidot savus hookus... taadeejÄdi uzlabojot.

*************************** 
https://www.youtube.com/watch?v=jdfNnNccDt0
From 2:14:15
Setup screen 
****************************