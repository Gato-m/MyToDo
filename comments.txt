ToDo - tips:

*************************** 
https://www.youtube.com/watch?v=jdfNnNccDt0
Till 40:23
Tab navigation, tabBar stylize, tabBar icons are done
****************************

1. Why Tabs is not styling by StyleSheet?

2. Icons - Ionicons from expo-router

3. Icon size={size} color={color}. Why?

*************************** 
https://www.youtube.com/watch?v=jdfNnNccDt0
From 40:23 till 53:28
Dark and Light mode
****************************

!!!!! TypeScript interfeisu lietošana ReactNative
!!!!! Context API lietošana ReactNative
!!!!! Provider lietošana ReactNative
!!!!! useContext lietošana ReactNative
!!!!! useState lietošana ReactNative
!!!!! useEffect lietošana ReactNative
!!!!! asyncStorage lietošana ReactNative


1. Local Storage - lai atcereetos kādu tēmu izvēlējās lietotājs.

2. To nodrošina speciāls hook(s)

3. Local storage vietā izmantojam async-storage

npm i @react-native-async-storage/async-storage

4. jāizveido themeProvider (fails ar 132 rindām koda tīrā React ar Typescript un nekā no ReactNative, izņemot async-storage pakotni). 
- importējam useState, useEffect un asyncStorage.
- Providerim ir useState - kas seko kāds reims izvēlēts
- useEffect - lai iegaumētu lietotāja izvēli pēdējā sistēmas palaišanas reizē.
- tad tiek izsaukta metode toggleDarkMode - kas ļauj pārslēgt tēmas un atjauno asyncStorage noglabātos datus (Dark modē izmantojam agrāk nodefinētās tumšās krāsas, Ligh Modē - gaišās).
- Lai to nodrošinātu izveidojam hooku useTheme, kurš izsauc context.
- const useTheme = () => {
    const context = useContext(ThemeContext);
    if (context === undefined) {
        throw new Error("useTheme must be used within a ThemeProvider");
    }

    return context;
};

5. Tagad pamata _layoutā (ne tab layoutā) viss kods jāietin (wrap), lai varētu izmantot Light un Dark modes. 

6. Ietinam visu ThemeProviderī (ko importējam nevis no react-native, bet no ../hooks/useTheme)

import { Stack } from "expo-router";
import { ThemeProvider } from "../hooks/useTheme";
import React from "react";

export default function RootLayout() {
  return (
    <ThemeProvider>
      <Stack screenOptions={{
        headerShown: false,
      }}>
        <Stack.Screen name="(tabs)" />
      </Stack>
    </ThemeProvider>
  );
}

7. Tagad pielabojam (tabs) screenus,lai izmantotu themes nodefinētās krāsas (color={color} etc.).
....
import { useTheme } from '../../hooks/useTheme';

  <Tabs screenOptions={{
            tabBarActiveTintColor: colors.primary,
            tabBarInactiveTintColor: colors.textMuted,
            tabBarStyle: {
                backgroundColor: colors.surface,
                borderTopWidth: 1,
                borderTopColor: colors.border,
.......

app lieto LightMode, jo hookaa useTheme useState sākumstāvoklis ir false, bet     const colors = isDarkMode ? darkColors : lightColors;
tātad sākumā sanāk light Mode.

8. Pievienojam tēmu pārslēgšanas toggle pogu (pārbaudam - tabBar maina tēmu. Pārstartējot app, tēma ir tā,kas bija pirms app aizvēršanas jo stāvooklis saglabājas async storage (local - iekārtā kurā instalēta app)) - importējam hooku, pievienojam no hooka toggleDarkMode metodi un uzrakstam uzrakstu "Toggle Mode"

import React from 'react'
import { StyleSheet, Text, View, TouchableOpacity } from 'react-native'
import useTheme from '../../hooks/useTheme'

export default function Index() {
    const { toggleDarkMode } = useTheme()

    return (
        <View style={styles.container}>
            <Text>Index</Text>
            <TouchableOpacity onPress={toggleDarkMode}>
                <Text>Toggle Mode</Text>
            </TouchableOpacity>
        </View>
    )
}

Tagad tēmu pārslēgšana darbojas, to vēlāk realizēsim ar atsevišku pārslēgšanas komponentu setting screenā.

*************************** 
https://www.youtube.com/watch?v=jdfNnNccDt0
From 53:28 till 1:10:00
Add DataBase and configure schema and functions
****************************

1. izmantojam backendam Convex (līdz 20 projektiem - bez maksas)  (var Firebase vai Supabase)- the backend AI  (DB, autentifikācija, fona uzdevumi un citas funkcijas)

2. Projektu Convexā var izveidot convex admin paneli vai no IDE termināļa:
- vienā terminālī palaists npx expo
- otrā terminālī -   npm i convex
tad -   npx convex dev

3. convex mapē izveido schema.ts failu. tad tajā izveido db tabulu sheemu.

import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
    todos: defineTable({
        text: v.string(),
        isCompleted: v.boolean(),
    }),
});


//Pēc schema.ts saglabāšanas tev ir jāizpilda:
bash
npx convex deploy
👉 Šī komanda:
augšupielādē shēmu uz Convex backendu,
atjauno metadatus admin panelī.
Ja tu esi tikai palaidis npx convex dev, tad shēma var būt lokāli aktīva, bet neparādās admin panelī.

//Vai schema.ts satur export default defineSchema(...)?
Convex identificē shēmu caur export default. Ja tu esi eksportējis to citādāk (piemēram, export const schema = ...), tad tā netiks uzskatīta par aktīvo shēmu.
Pareizi būtu:
ts
import { defineSchema, defineTable } from "convex/schema";

export default defineSchema({
  klienti: defineTable({
    vārds: "string",
    e_pasts: "string",
    izveidots: "number",
  }),
});


// ❗️ Svarīgi: jābūt export default, nevis export const.

// pēc DB pieslēgšanas visu laiku JĀIZMANTO DIVI TERMINĀĻI VIENLAIKUS !!!!

VIENĀ - npx expo start
OTRĀ - npx convex dev // tas nodrošinās veikto izmaiņu atjaunošanu concex kontā.

*********************

convex mapē izveido failu todo.ts

// lai iegūtu datus - sūtam pieprasījumu (query )GET)
) uz db, lai rediģētu vai dzēstu ierakstu - jāizmanto mutācija (createTodo, updateTodo, deleteTodo).

pieprasījumā iegūstam ctx - contekstu, kas ļauj sazināties ar db.

Pilns funkciju fails todo.Ts (viens GET pieprasijums un 5 mutācijas) :

import { ConvexError, v } from "convex/values";
import { mutation, query } from "../convex/_generated/server";

//iegūstam todos no db

export const getTodos = query({
    handler: async (ctx) => {
        const todos = await ctx.db.query("todos").order("desc").collect();
        return todos;
    }
});

// todo pievienoshanas funkcija

export const addTodo = mutation({
    args: { text: v.string() },
    handler: async (ctx, args) => {
        const todoId = await ctx.db.insert("todos", {
            text: args.text,
            isCompleted: false
        });
        return todoId;
    }
});


// pārslēgs pogai - ir vai nav todo

export const toggleTodo = mutation({
    args: { id: v.id("todos") },
    handler: async (ctx, args) => {
        const todo = await ctx.db.get(args.id);
        if (!todo) {
            throw new ConvexError("Todo not found");
        }
        await ctx.db.patch(args.id, {
            isCompleted: !todo.isCompleted
        });
    }
})

// todo dzēšanas funkcija

export const deleteTodo = mutation({
    args: { id: v.id("todos") },
    handler: async (ctx, args) => {
        await ctx.db.delete(args.id);
    }
})

// todo rediģēšanas funkcija

export const updateTodo = mutation({
    args: { id: v.id("todos"), text: v.string() },
    handler: async (ctx, args) => {
        await ctx.db.patch(args.id, {
            text: args.text
        });
    }
})

// reset app btn funkcija (visi todos tiek dzēsti)

export const clearAllTodos = mutation({
    handler: async (ctx) => {
        const todos = await ctx.db.query("todos").collect();


        //Delete all todos
        for (const todo of todos) {
            await ctx.db.delete(todo._id);
        }

        return { deleteCount: todos.length };
    }
})

*************************** 
https://www.youtube.com/watch?v=jdfNnNccDt0
From 1:10:00 - 1:14:27
Add functions to app
****************************

1. Importējam app/_layout.tsx failā ConvexProvider un ConverReactClient. un ietinam visu layoutu ieksh convex provider, lai visa app būtu saistīta ar convex. Pilns kods: 

import { ConvexProvider, ConvexReactClient } from "convex/react";
import { Stack } from "expo-router";
import React from "react";
import { ThemeProvider } from "../hooks/useTheme";

const convex = new ConvexReactClient(process.env.EXPO_PUBLIC_CONVEX_URL!, {
  unsavedChangesWarning: false,
});

export default function RootLayout() {
  return (
    <ConvexProvider client={convex}>
      <ThemeProvider>
        <Stack screenOptions={{
          headerShown: false,
        }}>
          <Stack.Screen name="(tabs)" />
        </Stack>
      </ThemeProvider>
    </ConvexProvider>
  );
}

2. Pievienojam datus no DB uz index screenu tab/index.tsx failā.

import { useQuery } from 'convex/react'
import { api } from '../../convex/_generated/api'


export default function Index() {
    const { toggleDarkMode } = useTheme()

    const todos = useQuery(api.todo.getTodos)
    console.log(todos)

    return (.......

// ieguustam tukshu masiivu jo nav veel neviens todo izveidots.

3. Pievienojam nepieciešaaas mutācija, kuras pēc tam izsaulsim ar touchableopacity :

    const todos = useQuery(api.todo.getTodos)
    console.log(todos)

    const addTodo = useMutation(api.todo.addTodo)

    const clearAllTodos = useMutation(api.todo.clearAllTodos)

    // un izsauc tās at touchableopacity:

   <TouchableOpacity onPress={() => addTodo({ text: "New Todo" })}>
                <Text>Add Todo</Text>
            </TouchableOpacity>
            <TouchableOpacity onPress={() => clearAllTodos()}>
                <Text>Clear All Todos</Text>
            </TouchableOpacity>


*************************** 
https://www.youtube.com/watch?v=jdfNnNccDt0
From 1:14:27 - 1:34:20
Setting up styles & Header component
****************************

1. ja mums ir divas tēmas -gaišā un tumšā, tad krāsas butu logiski ieviest vadoties no tēmas. Mēs varam const styles papildināt ar backgroundColor: colors.background, color: colors.text, bet varam to visu "wrapot" funkcijā.

2. izdzēšam no indeksa visu const styles,  un tā vietā uzrakstām funkciju - piem:
lai to "ieviestu" izveidojam: const styles = createStyles(colors) un tajā "wrapojam" veco const styles.

viss kods: 

import React from 'react';
import { StyleSheet, Text, TouchableOpacity, View } from 'react-native';
import useTheme, { ColorScheme } from '../../hooks/useTheme';

export default function Index() {
    const { toggleDarkMode, colors } = useTheme()

    const styles = createStyles(colors);

    return (
        <View style={styles.container}>
            <Text style={styles.text}>Index</Text>
            <TouchableOpacity onPress={toggleDarkMode}>
                <Text style={styles.text}>Toggle Mode</Text>
            </TouchableOpacity>
        </View>
    )
}

const createStyles = (colors: ColorScheme) => {      // colorScheme from hooks folder
    return StyleSheet.create({
        container: {
            flex: 1,
            alignItems: 'center',
            justifyContent: 'center',
            padding: 10,
            backgroundColor: colors.bg,
        },
        text: {
            color: colors.text,
        }
    });
};

// izveidojam assets/styles/home.styles.ts - tajā būs funkcijā wrapoti stili un failu settings.styles.ts - tas praktiski ir appa ui. Tagad indx failā iepriekš izveidotu const styles = createStyles(colors) varam dzēst pilnībā, tā vairs nav vajadzīga un krāsu ieviešanu index failā pielabojam uz - const homeStyles = createHomeStyles(colors), ari importējam to no import { createHomeStyles } from '@/assets/styles/home.styles';
un stilus return selcijā nomainam no styles uz homeStyles.

3. Lai teksti "neaizbrauc" lietojam SafeAreaView parastā View vietā. importējam no - import {SafeAreaView} from "react-native-safe-area-context" , arī saSafeAreaView  stilu nomainam uz homeStyles.safeArea - jo tas ir definēts iepriekš izveidotajos ui failos ka atsevišķs stils.

4. lai stilizētu katra todo fonu izmantojam self-closed componentu -  Expo Linear Gradient
npx expo install expo-linear-gradient

- hookos useTheme.tsx mums ir gradientu krāsas definētas.

5. Pielietojam linear gradientu - ietinam index safeAreaView ieksh <LinearGradient colors={colors.gradients.background} style={homeStyles.container}> un importjam to - import { LinearGradient } from 'expo-linear-gradient'; krāsas gradientā var mainīt hookos teemas krāsās definētajās gradient krāsās.

6. Tagad headeris. lai tas mainiitos - gaish tumshajā tēmā un tumsh gaišajā tēmā - izmanto statusBar komponentu. To ievieto pirms gradienta un visu return kodu iewrapo rect fragmentaa <></>
<StatusBar barStyle={colors.statusBarStyle} />  //dinamiski maina krāsu
import { StatusBar } from 'react-native';

6. Sākam veidot pirmā screena satura komponentus.

Component folderī Header.tsx failā <Header />

- kā progressBar procentus sarēķināt?

    const todos = useQuery(api.todos.getTodos);

    const completedCount = todos ? todos.filter((todo) => todo.isCompleted).length : 0;
    const totalCount = todos ? todos.length : 0;
    const progressPercentage = totalCount > 0 ? (completedCount / totalCount) * 100 : 0;

// pilns header code šajā bridī:

import { createHomeStyles } from "@/assets/styles/home.styles";
import { api } from "@/convex/_generated/api";
import useTheme from "@/hooks/useTheme";
import { Ionicons } from "@expo/vector-icons";
import { useQuery } from "convex/react";
import { LinearGradient } from "expo-linear-gradient";
import { Text, View } from "react-native";

const Header = () => {
    const { colors } = useTheme();
    const homeStyles = createHomeStyles(colors);

    const todos = useQuery(api.todo.getTodos);

    const completedCount = todos ? todos.filter((todo) => todo.isCompleted).length : 0;
    const totalCount = todos ? todos.length : 0;
    const progressPercentage = totalCount > 0 ? (completedCount / totalCount) * 100 : 0;

    return (
        <View style={homeStyles.header}>
            <View style={homeStyles.titleContainer}>
                <LinearGradient colors={colors.gradients.primary} style={homeStyles.iconContainer}>
                    <Ionicons name="flash-outline" size={28} color="#fff" />
                </LinearGradient>

                <View style={homeStyles.titleTextContainer}>
                    <Text style={homeStyles.title}>Today&apos;s Tasks  👀</Text>
                    <Text style={homeStyles.subtitle}>
                        {completedCount} of {totalCount} completed
                    </Text>
                </View>
            </View>

            <View style={homeStyles.progressContainer}>
                <View style={homeStyles.progressBarContainer}>
                    <View style={homeStyles.progressBar}>
                        <LinearGradient
                            colors={colors.gradients.success}
                            style={[homeStyles.progressFill, { width: `${progressPercentage}%` }]}
                        />
                    </View>
                    <Text style={homeStyles.progressText}>{Math.round(progressPercentage)}%</Text>
                </View>
            </View>
        </View>
    );
};

export default Header;

*************************** 
https://www.youtube.com/watch?v=jdfNnNccDt0
From 1:34:20 - 1:43:45
Add todos component <TodoInput />
****************************

1. nodrošinam stilizāciju atbilstoši tēmai. Iegūstam colores no custom hook useTheme, stilus no metodes createHomeStyles(colors) kas nosaka home screen stilus.

- importējam;
import { createHomeStyles } from '@/assets/styles/home.styles'
import useTheme from '@/hooks/useTheme'

un kodā:

export default function TodoInput() {
    const { colors } = useTheme();
    const homeStyles = createHomeStyles(colors);
    ...

2. Komponentā izmantosim mutāciju.
vispirms iegustam esošo stāvokli, tad mutācija, kas ļauj radīt jaunus todo (importējam mutāciju un api no convex):

const [newTodo, setNewTodo] = useState('')
const addTodo = useMutation(api.todo.addTodo)

3. izveidojam lietotaaja ui, un radam funkciju handleAddTodo, kas izsauks funkciju addTodo, kad ir ievadits todo un nospiests enter:

const handleAddTodo = async() => {}

tad pievienojam TextInput:
     <TextInput
                    style={homeStyles.input}
                    placeholder="Add new todo"
                    value={newTodo}
                    onChangeText={setNewTodo}
                    onSubmitEditing={handleAddTodo}
                    multiline
                    placeholderTextColor={colors.textMuted}
                />

     - onSubmitEditing={handleAddTodo} - nospiests enter  - nosūta mutāciju un pievieno jaunu todo un ar (onChangeText={setNewTodo}) atjauno useState - setNewTodo('')           

//////   !!!!!!!!  Cmd + K - izsauc ekrāna klaviaturu)

4. Pagaidām Enter nospiešana uz klaviatūras izveido jaunu rindkopu iekšh TextInput.
Tas jālabo - aizvācam multiline opciju un Enter strādā nosūtot mutāciju.

5. Pievienojam pogu "Add" kas nosūta mutāciju un pievieno jaunu todo. 
pogas fonā - linear gradient, teksta vietā icona, abi maina savu stilu atkarība no newTodo.trim() - ja ir ievadits todo un nospiests enter, tad pogas fon ir primary, ja nav ievadits todo, tad pogas fon ir muted.

                <TouchableOpacity onPress={handleAddTodo} activeOpacity={0.8} disabled={!newTodo.trim()}>
                <LinearGradient colors={newTodo.trim() ? colors.gradients.primary : colors.gradients.muted} style={[homeStyles.addButton, !newTodo.trim() ? homeStyles.addButtonDisabled ]}>
                    <Ionicons name="add" size={24} color="#fff" />
                </LinearGradient>
                </TouchableOpacity>


6. Nodrošinām pārbaudi ievadot jaunu todo - ja ir ievadīts jauns todo - tad to pievienojam, ja ne - tad funkcija handleAddTodo nestrādas, pievienojam arī trim() - lai noņemtu tukšas rakstzīmes, lai neaizsūt tikai tukšumu mutācijā.
Tāpēc arī nospiešot pievienot jaunu todo neizsaucam pa tiešo mutācijas funkciju addTodo, bet wrapojam to citā funkcijā handleAddTodo. Tas ļauj veikt ievades pārbaudi - try catch blokā.
App nav jaatjauno lai redzētu vai todo pievienojies, to nodrošina funlcija  const todos = useQuery(api.todo.getTodos) no componenta header - convex caur socket atsūta nepieciešamos datus - tas strādā real time from the box. 

*************************** 
https://www.youtube.com/watch?v=jdfNnNccDt0
From 1:43:50 - 2:01:20
Show Todos at home screen as FlatList
****************************

1. Var importēt api, izmantot GET pieprasījumu (const todos = useQuery(api.todo.getTodos) un saņemt visus todo no db un tad tos parādīt home screenā. Tad izmantojam 
{todos?.map((todo) => <Text key={todo._id}>{todo.text}</Text>)}
un iegūstam visu todo sarakstu.

2. Efektīvāks šādā gadījumā ir FlatList komponents. jo map gadījumā ielādējot screenu tiek renderēti visi simts todo, arī tie, kas ir "aiz kadra" , flatlist gadījumā tiek renderēti tikai tie kas redzami ekrānā. parējie tiek renderēti pie scrolla... tas ir efektīvāk. Ja zināms ka saraksts neliels - var izmantot arī map, ja nav - flatlist.

3. Ja nezinām cik garš ir saraksts un cik ātri tas ielādēsies ir jēga pievienot ielādes komponentu. Ja datu ielāde no convex ir procesā un nav pabeigta - consolē rāda undefined - tātad atrodamies isLoading stāvoklī, pretējā gadījumā - false.

const isLoading = todos === undefined

- izveidojam komponentu LoadingSpinner:

import { createHomeStyles } from "@/assets/styles/home.styles";
import useTheme from "@/hooks/useTheme";
import { LinearGradient } from "expo-linear-gradient";
import { ActivityIndicator, Text, View } from "react-native";

const LoadingSpinner = () => {
    const { colors } = useTheme();

    const homeStyles = createHomeStyles(colors);

    return (
        <LinearGradient colors={colors.gradients.background} style={homeStyles.container}>
            <View style={homeStyles.loadingContainer}>
                <ActivityIndicator size="large" color={colors.primary} />
                <Text style={homeStyles.loadingText}>Loading your todos...</Text>
            </View>
        </LinearGradient>
    );
};

export default LoadingSpinner;


- tad ieimportējam to index failā un ievietojam kodā. varam pārbaudīt, ja to "ieslēdzam" kodu :
    if (isLoading) return <LoadingSpinner />
aizvietojam ar 
    if (true) return <LoadingSpinner />

 4. pārejam pie FlatList.
 pirmais parametrs - datu masīvs
 otrais - funkcija kas renderē katru todo. jārenderē tieši elements (item) nevis todo.

 renderItem={({ item }) => <Text key={item._id}>{item.text}</Text>}

  - tagad šo funkcijas kodu var ievietot jaunizveidotajāfunkcijā renderTodoItem, kurā izmantojam importētā dokumenta datu tipu Todo kas nāk no Convex:

// type Todo = {
//     _id: string;
//     text: string;
//     isCompleted: boolean;
// }

to rakstam kā: 
import { Doc } from '@/convex/_generated/dataModel';

type Todo = Doc<todos>

// tā var iegūt datu tipu no Convex
// tagad funkcija datu attēlošanai FlatListā:

const renderTodoItem = ({ item }: (item: Todo)) => {
    return (
        <View style={homeStyles.todoItem}>
            <Text style={homeStyles.todoText}>{item.text}</Text>
        </View>
    )
}

viss FlatList. key - katra todo identifikators, style - todo elementa stils, containerStyle - todo kontainera stils:

                    <FlatList
                        data={todos}
                        renderItem={renderTodoItem}
                        keyExtractor={(item) => item._id}
                        style={homeStyles.todoList}
                        contentContainerStyle={homeStyles.todoListContent}
                        showsVerticalScrollIndicator={false}
                    />

5.  Katra todo elementa stils ir todoItemWrapper un todoItem. todoItemWrapper ir linear gradient, todoItem ir todo elementa stils. todoText ir todo elementa teksts. Ja todo wrappera gradientu gribam pagriezt par 45 grādiem jāsaprot ideja:

0/0 --------- 1    // x ass
    |       |
    |       |
    |       |
1   --------- 1/1
    y ass

gradients 45 grādu leņķī:

<LinearGradient colors={colors.gradients.surface} 
    style={homeStyles.todoItem}
    start={{ x: 0, y: 0 }}
    end={{ x: 1, y: 1 }}
    >
</LinearGradient>

6. Tatad kopā katra todo wrapperis ar 45 grādu gradientu un apaļu pogu, kurā chekot vai todo ir pabeigts un ja ir pabeigts - tad pogas krāsa ir success, ja nav pabeigts - tad pogas krāsa ir muted un, ja pabeigts - tad checked ikona ir visible. Pilns kods:

const renderTodoItem = ({ item }: { item: Todo }) => {
        return (
            <View style={homeStyles.todoItemWrapper}>
                <LinearGradient colors={colors.gradients.surface}
                    style={homeStyles.todoItem}
                    start={{ x: 0, y: 0 }}
                    end={{ x: 1, y: 1 }}
                >
                    <TouchableOpacity
                        style={homeStyles.checkbox}
                        activeOpacity={0.7}
                        onPress={() => { }}>
                        <LinearGradient
                            colors={item.isCompleted ? colors.gradients.success : colors.gradients.muted}
                            style={[homeStyles.checkboxInner, { borderColor: item.isCompleted ? "transparent" : colors.border }]}
                        >
                            {item.isCompleted && <Ionicons name="checkmark" size={24} color="white" />}
                        </LinearGradient>
                    </TouchableOpacity>
                    <Text style={homeStyles.todoText}>{item.text}</Text>
                </LinearGradient >
            </View >
        )
    }


7. veidojam funkciju handleToggleTodo - kas izsauc mutāciju updateTodo un pievieno todo id un ja todo ir pabeigts - tad pievieno true, ja nav pabeigts - tad pievieno false

    const handleToggleTodo = async (id: Id<"todos">) => {.....

// var jau id tipu norādīt kā stringu, bet
lai typescript nelamātos, mums vajag importēt Id no convex:
import { Id } from "@/convex/_generated/dataModel";

pirms pārslēgt todo stāvokli nosakām, ka ja todo ir pabeigts - tad pievieno true, ja nav pabeigts - tad pievieno false (tas jau ir noteikts convex db ar funkciju toggleTodo). Tāpēc lietojam mutāciju kā api - tas atcels todo esošo stāvokli. Tad funkcijā catch blokā ieliekampazinojumu, ja neizdevās pārslēgt esošo stāvokli.

    const toggleTodo = useMutation(api.todo.toggleTodo);

    const handleToggleTodo = async (id: Id<"todos">) => {
        try {
            await toggleTodo({ id });
        } catch (error) {
            console.log("Error toggling todo", error);
            Alert.alert("Error", "Failed to toggle todo");
        }
    };

8. Noformējam katra todo teksta stilu - ja todo ir pabeigts - tad teksts ir line-through, ja nav pabeigts - tad teksts ir normals. Tas viss ieksh atsevishkja View containera:

    <View style={homeStyles.todoTextContainer}>
                        <Text
                            style={[homeStyles.todoText,
                            item.isCompleted && {
                                textDecorationLine: "line-through",
                                color: colors.textMuted,
                                opacity: 0.6,
                            },]} >
                            {item.text}</Text>
                    </View>

9,. tagad katram todo texta blokam jāpievieno divas pogas - edit un delete.

<View style={homeStyles.todoActions}>
                <TouchableOpacity onPress={() => handleEditTodo(item)} activeOpacity={0.8}>
                  <LinearGradient colors={colors.gradients.warning} style={homeStyles.actionButton}>
                    <Ionicons name="pencil" size={14} color="#fff" />
                  </LinearGradient>
                </TouchableOpacity>
                <TouchableOpacity onPress={() => handleDeleteTodo(item._id)} activeOpacity={0.8}>
                  <LinearGradient colors={colors.gradients.danger} style={homeStyles.actionButton}>
                    <Ionicons name="trash" size={14} color="#fff" />
                  </LinearGradient>
                </TouchableOpacity>
              </View>

10. Vel vienanianse - kas notiek, ja todo masīvs bus tukšs. Tad var izmantot 
 - ListEmptyComponent={<EmptyState />}

izveidojam EmptyState komponentu: 

import { createHomeStyles } from "@/assets/styles/home.styles";
import useTheme from "@/hooks/useTheme";
import { Ionicons } from "@expo/vector-icons";
import { LinearGradient } from "expo-linear-gradient";
import { Text, View } from "react-native";

const EmptyState = () => {
  const { colors } = useTheme();

  const homeStyles = createHomeStyles(colors);

  return (
    <View style={homeStyles.emptyContainer}>
      <LinearGradient colors={colors.gradients.empty} style={homeStyles.emptyIconContainer}>
        <Ionicons name="clipboard-outline" size={60} color={colors.textMuted} />
      </LinearGradient>
      <Text style={homeStyles.emptyText}>No todos yet!</Text>
      <Text style={homeStyles.emptySubtext}>Add your first todo above to get started</Text>
    </View>
  );
};
export default EmptyState;


*************************** 
https://www.youtube.com/watch?v=jdfNnNccDt0
From 2:01:20 - 2:05:13
Delete todos functionality
****************************

1. Delete todos. 

- izveidojam jaunu api mutāciju un saglabājam mainīgajā deleteTodo:
        const deleteTodo = useMutation(api.todo.deleteTodo);

- un izsaucam to ar handleDeleteTodo funkciju:
// vēl viena fiška - pirms dzēšanas parādās alert logs ar komandu (Delete Todo) un divām izvēlēm - dzēst vai nedzēst šo todo. katra izvēle - cancel iun delete ir atsevišķs objekts masīvā kas ir iekļauts alert logā.


    const handleDeleteTodo = async (id: Id<"todos">) => {

        Alert.alert("Delete Todo", "Are you sure you want to delete this todo?", [
            {
                text: "Cancel",
                onPress: () => console.log("Cancel Pressed"),
                style: "cancel",
            },
            {
                text: "Delete",
                style: "destructive",
                onPress: () => deleteTodo({ id }),
            },
        ]);
    };

*************************** 
https://www.youtube.com/watch?v=jdfNnNccDt0
From 2:05:13 - 2:14:01
Edit todos functionality
****************************

1. Edit todo. Attiecīgā todo wrapperī funkcija handleEditTodo mainīsi interfeisa daļu - parādīsies editējams inputs un divas pogas - save (atceļ iepriekšējo stāvokli) un cancel (atceļ darbību). Tātad vajadzīgi divi stāvokļi - viens todo rediģēšanas id un otrs - rediģējamā todo teksts. lai atjaunotu tikai to, kas nepieciešams nepieciešams izmantot redigēšanas id.

2. Tagad varam dzēst ieprikš lietoto toggleTodo metodi un izmantot useState hooku.

const updateTodo = useMutation(api.todo.updateTodo);

const [editingId, setEditingId] = useState<Id<"todos"> | null>(null);
const [editText, setEditText] = useState<string>("");

// tagad funkcijas: handleEditTodo atrod labojamā todo id un tekstu, const handleSaveEdit - ļauj labot todo, const handleCancelEdit - atceļ rediģēšanu :

   const handleEditTodo = (todo: Todo) => {
        setEditingId(todo._id)
        setEditText(todo.text)
    }
    const handleSaveEdit = async () => {
        if (editingId) {
            try {
                await updateTodo({ id: editingId, text: editText.trim ()})
                setEditingId(null)
                setEditText("")
            } catch (error) {
                console.log("Error updating todo", error)
                Alert.alert("Error", "Failed to update todo")
            }
        }
        const handleCancelEdit = () => {
            setEditingId(null)
            setEditText("")
        }
    }

3. tagad var izsaukt tikko izveidotās funkcija lietotaaja interfeisā, bet mums nav šī stāvokļa. Tāpēc atrodam katra todo wrappera text container ( kurā gatavojamies veikt izmaiņas )

/////////// Vispirms pielabojam renderTodoItem funkciju un nosakām kad tiks pārrenderēts ToDo:

 const renderTodoItem = ({ item }: { item: Todo }) => {
        const isEditing = editingId === item._id
        return (.........

///////////  Bija: 

<View style={homeStyles.todoTextContainer}>
                        <Text
                            style={[homeStyles.todoText,
                            item.isCompleted && {
                                textDecorationLine: "line-through",
                                color: colors.textMuted,
                                opacity: 0.6,
                            },]} >
                            {item.text}</Text>

                        <View style={homeStyles.todoActions}>
                            <TouchableOpacity onPress={() => handleEditTodo(item)} activeOpacity={0.8}>
                                <LinearGradient colors={colors.gradients.warning} style={homeStyles.actionButton}>
                                    <Ionicons name="pencil" size={14} color="#fff" />
                                </LinearGradient>
                            </TouchableOpacity>
                            <TouchableOpacity onPress={() => handleDeleteTodo(item._id)} activeOpacity={0.8}>
                                <LinearGradient colors={colors.gradients.danger} style={homeStyles.actionButton}>
                                    <Ionicons name="trash" size={14} color="#fff" />
                                </LinearGradient>
                            </TouchableOpacity>
                        </View>
                    </View>
					
					
/////////// sākam interfeisa izmaiņas:

editējamā todo containera textInput:

 isEditing ? (
                    <View style={homeStyles.editContainer}>
                        <TextInput
                            value={editText}
                            onChangeText={setEditText}
                            style={homeStyles.editInput}
                            autoFocus
                            multiline
                            placeholder="Edit todo"
                            placeholderTextColor={colors.textMuted}
                        />
                    </View>
                    ) : (
                    <View style={homeStyles.todoTextContainer}>...

///////////  nospiežot redigēšanaspogu nekas nenotiek jo nav nodefinēta pogas funkcijas . pievienojam pogai funkciju handleEditTodo:

<TouchableOpacity onPress={() => handleEditTodo(item)} activeOpacity={0.8}>
					
.....
					
///////////   Pēc jaunā - edit stāvokļa ievietošanas pilns abu todo containeru kods (ar nosacījumu isediting):


                    {isEditing ? (
                        <View style={homeStyles.editContainer}>
                            <TextInput
                                value={editText}
                                onChangeText={setEditText}
                                style={homeStyles.editInput}
                                autoFocus
                                multiline
                                placeholder="Edit todo"
                                placeholderTextColor={colors.textMuted}
                            />

                            <View style={homeStyles.editButtons}>
                                <TouchableOpacity onPress={handleSaveEdit} activeOpacity={0.8}>
                                    <LinearGradient colors={colors.gradients.success} style={homeStyles.editButton}>
                                        <Ionicons name="checkmark" size={16} color="#fff" />
                                        <Text style={homeStyles.editButtonText}>Save</Text>
                                    </LinearGradient>
                                </TouchableOpacity>

                                <TouchableOpacity onPress={handleCancelEdit} activeOpacity={0.8}>
                                    <LinearGradient colors={colors.gradients.danger} style={homeStyles.editButton}>
                                        <Ionicons name="close" size={16} color="#fff" />
                                        <Text style={homeStyles.editButtonText}>Cancel</Text>
                                    </LinearGradient>
                                </TouchableOpacity>
                            </View>
                        </View>

                    ) : (
                        <View style={homeStyles.todoTextContainer}>
                            <Text
                                style={[homeStyles.todoText,
                                item.isCompleted && {
                                    textDecorationLine: "line-through",
                                    color: colors.textMuted,
                                    opacity: 0.6,
                                },]} >
                                {item.text}</Text>

                            <View style={homeStyles.todoActions}>
                                <TouchableOpacity onPress={() => handleEditTodo(item)} activeOpacity={0.8}>
                                    <LinearGradient colors={colors.gradients.warning} style={homeStyles.actionButton}>
                                        <Ionicons name="pencil" size={14} color="#fff" />
                                    </LinearGradient>
                                </TouchableOpacity>
                                <TouchableOpacity onPress={() => handleDeleteTodo(item._id)} activeOpacity={0.8}>
                                    <LinearGradient colors={colors.gradients.danger} style={homeStyles.actionButton}>
                                        <Ionicons name="trash" size={14} color="#fff" />
                                    </LinearGradient>
                                </TouchableOpacity>
                            </View>
                        </View>
                    )
                    }

                 
//////// nav iisti tīrs un moderns kods, to var sadaliit komponentos vai izveidot savus hookus... taadeejādi uzlabojot.

*************************** 
https://www.youtube.com/watch?v=jdfNnNccDt0
From 2:14:15
Setup screen 
****************************