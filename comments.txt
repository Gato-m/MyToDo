*************************** 
https://www.youtube.com/watch?v=jdfNnNccDt0
Till 40:23
Tab navigation, tabBar stylize, tabBar icons are done
****************************

1. Why Tabs is not styling by StyleSheet?

2. Icons - Ionicons from expo-router

3. Icon size={size} color={color}. Why?

*************************** 
https://www.youtube.com/watch?v=jdfNnNccDt0
From 40:23 till 53:28
Dark and Light mode
****************************

!!!!! TypeScript interfeisu lietoÅ¡ana ReactNative
!!!!! Context API lietoÅ¡ana ReactNative
!!!!! Provider lietoÅ¡ana ReactNative
!!!!! useContext lietoÅ¡ana ReactNative
!!!!! useState lietoÅ¡ana ReactNative
!!!!! useEffect lietoÅ¡ana ReactNative
!!!!! asyncStorage lietoÅ¡ana ReactNative


1. Local Storage - lai atcereetos kÄdu tÄ“mu izvÄ“lÄ“jÄs lietotÄjs.

2. To nodroÅ¡ina speciÄls hook(s)

3. Local storage vietÄ izmantojam async-storage

npm i @react-native-async-storage/async-storage

4. jÄizveido themeProvider (fails ar 132 rindÄm koda tÄ«rÄ React ar Typescript un nekÄ no ReactNative, izÅ†emot async-storage pakotni). 
- importÄ“jam useState, useEffect un asyncStorage.
- Providerim ir useState - kas seko kÄds reims izvÄ“lÄ“ts
- useEffect - lai iegaumÄ“tu lietotÄja izvÄ“li pÄ“dÄ“jÄ sistÄ“mas palaiÅ¡anas reizÄ“.
- tad tiek izsaukta metode toggleDarkMode - kas Ä¼auj pÄrslÄ“gt tÄ“mas un atjauno asyncStorage noglabÄtos datus (Dark modÄ“ izmantojam agrÄk nodefinÄ“tÄs tumÅ¡Äs krÄsas, Ligh ModÄ“ - gaiÅ¡Äs).
- Lai to nodroÅ¡inÄtu izveidojam hooku useTheme, kurÅ¡ izsauc context.
- const useTheme = () => {
    const context = useContext(ThemeContext);
    if (context === undefined) {
        throw new Error("useTheme must be used within a ThemeProvider");
    }

    return context;
};

5. Tagad pamata _layoutÄ (ne tab layoutÄ) viss kods jÄietin (wrap), lai varÄ“tu izmantot Light un Dark modes. 

6. Ietinam visu ThemeProviderÄ« (ko importÄ“jam nevis no react-native, bet no ../hooks/useTheme)

import { Stack } from "expo-router";
import { ThemeProvider } from "../hooks/useTheme";
import React from "react";

export default function RootLayout() {
  return (
    <ThemeProvider>
      <Stack screenOptions={{
        headerShown: false,
      }}>
        <Stack.Screen name="(tabs)" />
      </Stack>
    </ThemeProvider>
  );
}

7. Tagad pielabojam (tabs) screenus,lai izmantotu themes nodefinÄ“tÄs krÄsas (color={color} etc.).
....
import { useTheme } from '../../hooks/useTheme';

  <Tabs screenOptions={{
            tabBarActiveTintColor: colors.primary,
            tabBarInactiveTintColor: colors.textMuted,
            tabBarStyle: {
                backgroundColor: colors.surface,
                borderTopWidth: 1,
                borderTopColor: colors.border,
.......

app lieto LightMode, jo hookaa useTheme useState sÄkumstÄvoklis ir false, bet     const colors = isDarkMode ? darkColors : lightColors;
tÄtad sÄkumÄ sanÄk light Mode.

8. Pievienojam tÄ“mu pÄrslÄ“gÅ¡anas toggle pogu (pÄrbaudam - tabBar maina tÄ“mu. PÄrstartÄ“jot app, tÄ“ma ir tÄ,kas bija pirms app aizvÄ“rÅ¡anas jo stÄvooklis saglabÄjas async storage (local - iekÄrtÄ kurÄ instalÄ“ta app)) - importÄ“jam hooku, pievienojam no hooka toggleDarkMode metodi un uzrakstam uzrakstu "Toggle Mode"

import React from 'react'
import { StyleSheet, Text, View, TouchableOpacity } from 'react-native'
import useTheme from '../../hooks/useTheme'

export default function Index() {
    const { toggleDarkMode } = useTheme()

    return (
        <View style={styles.container}>
            <Text>Index</Text>
            <TouchableOpacity onPress={toggleDarkMode}>
                <Text>Toggle Mode</Text>
            </TouchableOpacity>
        </View>
    )
}

Tagad tÄ“mu pÄrslÄ“gÅ¡ana darbojas, to vÄ“lÄk realizÄ“sim ar atseviÅ¡ku pÄrslÄ“gÅ¡anas komponentu setting screenÄ.

*************************** 
https://www.youtube.com/watch?v=jdfNnNccDt0
From 53:28 till .....
Add DataBase
****************************

1. izmantojam backendam Convex (lÄ«dz 20 projektiem - bez maksas)  (var Firebase vai Supabase)- the backend AI  (DB, autentifikÄcija, fona uzdevumi un citas funkcijas)

2. Projektu ConvexÄ var izveidot convex admin paneli vai no IDE terminÄÄ¼a:
- vienÄ terminÄlÄ« palaists npx expo
- otrÄ terminÄlÄ« -   npm i convex
tad -   npx convex dev

3. convex mapÄ“ izveido schema.ts failu. tad tajÄ izveido db tabulu sheemu.

import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
    todos: defineTable({
        text: v.string(),
        isCompleted: v.boolean(),
    }),
});


//PÄ“c schema.ts saglabÄÅ¡anas tev ir jÄizpilda:
bash
npx convex deploy
ğŸ‘‰ Å Ä« komanda:
augÅ¡upielÄdÄ“ shÄ“mu uz Convex backendu,
atjauno metadatus admin panelÄ«.
Ja tu esi tikai palaidis npx convex dev, tad shÄ“ma var bÅ«t lokÄli aktÄ«va, bet neparÄdÄs admin panelÄ«.

//Vai schema.ts satur export default defineSchema(...)?
Convex identificÄ“ shÄ“mu caur export default. Ja tu esi eksportÄ“jis to citÄdÄk (piemÄ“ram, export const schema = ...), tad tÄ netiks uzskatÄ«ta par aktÄ«vo shÄ“mu.
Pareizi bÅ«tu:
ts
import { defineSchema, defineTable } from "convex/schema";

export default defineSchema({
  klienti: defineTable({
    vÄrds: "string",
    e_pasts: "string",
    izveidots: "number",
  }),
});


// â—ï¸ SvarÄ«gi: jÄbÅ«t export default, nevis export const.

// pÄ“c DB pieslÄ“gÅ¡anas visu laiku JÄ€IZMANTO DIVI TERMINÄ€Ä»I VIENLAIKUS !!!!

VIENÄ€ - npx expo start
OTRÄ€ - npx convex dev // tas nodroÅ¡inÄs veikto izmaiÅ†u atjaunoÅ¡anu concex kontÄ.

*********************

convex mapÄ“ izveido failu todo.ts

// lai iegÅ«tu datus - sÅ«tam pieprasÄ«jumu (query )GET)
) uz db, lai rediÄ£Ä“tu vai dzÄ“stu ierakstu - jÄizmanto mutÄcija (createTodo, updateTodo, deleteTodo).

pieprasÄ«jumÄ iegÅ«stam ctx - contekstu, kas Ä¼auj sazinÄties ar db.

Pilns funkciju fails todo.Ts (viens GET pieprasijums un 5 mutÄcijas) :

import { ConvexError, v } from "convex/values";
import { mutation, query } from "../convex/_generated/server";

//iegÅ«stam todos no db

export const getTodos = query({
    handler: async (ctx) => {
        const todos = await ctx.db.query("todos").order("desc").collect();
        return todos;
    }
});

// todo pievienoshanas funkcija

export const addTodo = mutation({
    args: { text: v.string() },
    handler: async (ctx, args) => {
        const todoId = await ctx.db.insert("todos", {
            text: args.text,
            isCompleted: false
        });
        return todoId;
    }
});


// pÄrslÄ“gs pogai - ir vai nav todo

export const toggleTodo = mutation({
    args: { id: v.id("todos") },
    handler: async (ctx, args) => {
        const todo = await ctx.db.get(args.id);
        if (!todo) {
            throw new ConvexError("Todo not found");
        }
        await ctx.db.patch(args.id, {
            isCompleted: !todo.isCompleted
        });
    }
})

// todo dzÄ“Å¡anas funkcija

export const deleteTodo = mutation({
    args: { id: v.id("todos") },
    handler: async (ctx, args) => {
        await ctx.db.delete(args.id);
    }
})

// todo rediÄ£Ä“Å¡anas funkcija

export const updateTodo = mutation({
    args: { id: v.id("todos"), text: v.string() },
    handler: async (ctx, args) => {
        await ctx.db.patch(args.id, {
            text: args.text
        });
    }
})

// reset app btn funkcija (visi todos tiek dzÄ“sti)

export const clearAllTodos = mutation({
    handler: async (ctx) => {
        const todos = await ctx.db.query("todos").collect();


        //Delete all todos
        for (const todo of todos) {
            await ctx.db.delete(todo._id);
        }

        return { deleteCount: todos.length };
    }
})









